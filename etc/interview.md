# 오버로딩 vs 오버라이딩

**오버로딩(Overloading)** : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술 **(확장)**

**오버라이딩(Overriding)** : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 **재정의**해서 사용

# 인터페이스와 추상 클래스

**추상메서드**

정의 : 내용이 없는 메서드, 구현(정의)는 하지 않고 선언만 한 메서드

목적 : 메서드의 내용이 너무 일반적인 내용이라 부모 클래스에서 구체화하여 정의할 필요가 없을 경우, 추상메서드로 **선언만하고 상속받은 자식 클래스에서 재정의하도록 할 때 사용**

**추상클래스(abstract class)**

정의 : - 한 개 이상의 추상메서드를 가지는 클래스

- 일반적인 클래스는 세부적이고, 구체적 ex) 고양이과, 개과

- 반면 추상클래스는 일반클래스에 비해 구체적이지 않고 추상적 ex) 고양이, 사자, 강아지

목적 : 추상메서드는 선언만되고 구현이 되지 않은 불완전한 메서드이므로 객체로 생성되어서는 안됩니다.

이런 클래스(추상메서드가 포함된 클래스)는 추상클래스로 선언하여 객체 생성을 금지시킵니다.

**인터페이스 (implements 인터페이스명)**

- 추상클래스와 비슷한 기능을 하지만 극단적인 경우이다.

- 추상메서드와 상수로만 이루어져 있다.(=로직을 작성할 수 없음)

- 다중 상속이 가능하다.

클래스에 인터페이스 상속 시 인터페이스 내에 정의된 모든 추상메서드를 구현(오버라이드) 해야만 정상적인 컴파일이 가능합니다.

## 공통점

- 선언만 있고 구현부가 없음
- 상속받은 자식이 구현을 반드시 하도록 할때 사용
- type이 같아야 함

## 차이점

| 인터페이스 | 추상클래스 |
| --- | --- |
| 구현 객체의 같은 동작을 보장하기 위함 | 추상클래스를 상속받아 기능을 사용하고 확장시키기 위함 |
| 다중 상속 가능 | 다중 상속 불가 |
| 상수 + 추상 메서드 | 일반 변수 + 일반 메서드 + 추상 메서드 |
| 생성자와 일반변수 가질 수 없다 | 생성자와 일반변수 가능 |
| implements | extends |
| 메서드 선언만 가능 | 메서드의 부분적 구현 가능 |

# 다형성

상속 관계에서 하나의 참조변수(부모객체)가 여러 개의 다른 타입(자식객체)을 가질 수 있는 것
➡️  부모 클래스 타입의 참조변수가 여러개의 자식 클래스 주소를 가질 수 있다

# 컬렉션프레임워크란?

![image](https://user-images.githubusercontent.com/87118337/149163340-fa647796-85bb-4f3f-b8e6-714008abfe22.png)

여러 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합

자바의 인터페이스를 사용하여 구현됨

List, Set, Map 세가지의 주요 인터페이스가 있다

## List

Collection 인터페이스를 상속 받음 → 공통된 부분을 Collection 인터페이스에서 정의하고 있음

순서가 있는 데이터의 집합으로 데이터 중복 허용 (ArrayList, Stack)

## Set

Collection 인터페이스를 상속 받음 → 공통된 부분을 Collection 인터페이스에서 정의하고 있음

순서가 없는 데이터의 집합으로 데이터의 중복 허용 안함 (HashSet, TreeSet)

## Map

Collection 인터페이스를 상속 받지 않음 (구조상의 차이로 인해)

키와 값의 한 쌍으로 이루어지는 데이터의 집합으로, 순서가 없음

키는 중복 불가, 값은 중복 허용 (HashMap, TreeMap, Hashtable)

# 객체지향 프로그래밍의 정의와 특징

문제를 여러개의 객체 단위로 나누어서 처리하는 방식

프로그래밍에서 필요한 데이터를 추상화시켜서 상태와 행위를 가진 객체를 만들고, 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

## 장점

- 코드 재사용이 용이 : 다른 클래스를 가져와서 이용하거나 상속을 통해 확장 가능
- 유지보수가 쉬움 : 절차 지향에서는 코드를 수정하려면 일일이 찾아 수정해야 하는데 객체 지향은 수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 됨
- 대형 프로젝트에 적합 : 클래스 단위로 모듈화 시켜서 개발 가능하므로 여러명 여러 회사에서 프로젝트를 개발할 때 업무 분담이 쉽다

## 단점

- 처리 속도가 상대적으로 느림
- 객체가 많으면 용량이 커질 수 있음
- 설계 단계에서 많은 시간 및 노력이 필요

## 클래스와 인스턴스

클래스는 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것

인스턴스(객체)는 클래스에서 정의한 것을 토대로 실제 매모리에 할당된 것 (실제 프로그램에서 사용되는 데이터)

## 여기서 추상화란

공통의 속성이나 기능을 묶어서 이름 붙이는 것을 추상화라고 함

## 캡슐화란

1. 코드를 재수정 없이 재활용 하는 것
2. 접근 제어자를 통한 정보 은닉

2가지 목적을 가지고 있는데, 캡슐화를 통해 객체가 외부에 노출하지 않아야 할 정보나 기능을 접근제어자(private, public...) 를 통해 적절히 제어권한이 있는 객체에서만 접근할 수 있도록 함

그래서 코드 수정할 때 책임이 있는 객체만 수정하면 되어서 영향 범위를 예측하는 것이 수월

관련된 기능과 특성을 한곳에 모으고 분류하기 때문에 객체 재활용이 원활함

기능과 특성의 모음을 클래스라는 캡슐에 분류해서 넣는 것이 캡슐화

객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶음

# POST, GET 방식의 차이

## GET

쿼리 스트링을 통해 요청하는 방식

말그대로 클라이언트에서 서버에서 어떠한 리소스로부터 정보를 요청할 때 사용되는 메서드

게시판 조회 등에 쓰임

URL 끝에 파라미터로 포함되어 전송되기 때문에 URL에 name과 value가 모두 노출됨

길이 제한이 있음

요청 내용이 파라미터에 다 노출되기 때문에 보안상 문제가 있을 수 있음

멱등

## POST

클라이언트에서 서버로 리소스를 생성하거나 업데이트 하기 위해 데이터를 보낼때 사용되는 메서드

게시글 작성, 수정, 삭제 등에 쓰임

전송할 데이터를 파라미터로 담아 보내는 GET과 달리 HTTP 메시지의 body 부분에 담아서 서버로 보냄

길이 제한이 따로 없어서 용량이 큰 데이터를 보낼 때 사용

파라미터로 노출되지 않기 때문에 보안이 필요한 부분에서 많이 사용됨

보통 form 데이터로 많이 보냄

멱등 아님

## 멱등이란?

멱등은 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 의미

GET은 리소스를 조회한다는 점에서 여러번 요청하더라도 응답이 똑같음

POST는 리소스를 생성하거나 업데이트 할때 사용되기 때문에 멱등이 아님 (요청이 발생하면 서버가 변경될 수 있으므로)

# 쿠키와 세션의 차이

## 쿠키와 세션은 왜 사용하죠?

HTTP 프로토콜의 약점을 보완하기 위해서 사용됨

HTTP는 connectionless, stateless한 특징을 가지므로 서버는 클라이언트가 누구인지 매번 확인해야 함

### connectionless

클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버림

request를 서버에 보내면 서버에서는 요청에 맞는 response를 보내고 접속을 끊음

헤더에 keep-alive라는 값을 주면 커넥션을 재활용 할 수 있음

### stateless

통신이 끝나면 상태를 유지하지 않음

연결을 끊는 순간 클아이언트와 서버의 통신이 끝나고 상태 정보는 유지 하지 않는 특성이 있다

## 쿠키

쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일

유효시간을 명시할 수 있고, 유효시간이 지정되면 브라우저 종료시에도 인증이 유지된다

사용자가 따로 요청하지 않아도 브라우저가 request시에 request header를 넣어서 자동으로 서버에 전송

### 동작 방식

1. 클라이언트가 페이지 요청
2. 서버에서 쿠키 생성
3. HTTP 헤더에 쿠키를 포함시켜서 응담
4. 브라우저가 종료되어도 쿠키 만료기간이 있다면 클라이언트에서 보관
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함꼐 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때, 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜서 응답

### 사용 예시

아이디 비밀번호 저장

장바구니

팝업창의 ‘오늘은 더 이상 이 팝업을 표시하지 않음’

## 세션

쿠키를 기반으로 하지만 사용자 정보 파일은 브라우저에서 관리하는 쿠키와 달리 세션은 서버측에서 관리

서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하고, 웹 브라우저가 서버에 접속하여 브라우저를 종료할 때까지 인증 상태를 유지

접속 시간에 제한을 두어 일정 시간 응답이 없을 경우, 정보가 유지되지 않게 설정도 가능

정보가 서버에 저장되기 떄문에 쿠키보다 보안에 좋지만 사용자가 많아질수록 서버 메모리를 많이 차지한다는 단점이 있음

동접자 수가 많은 웹사이트의 경우, 서버 과부하가 발생할 수 있어 성능 저하의 요인이 되기도 함

클라이언트가 request를 보내면 해당 서버의 엔진이 클라이언트에게 유일한 ID값을 부여하는데 이것이 바로 세션 ID

### 동작 방식

1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고, 가지고 있음
3. 클라이언트는 서버에 요청 할 때 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청함
4. 서버는 세션 ID를 전달 받아서 별다른 작업 없이 세션 ID로 세션에 있는 클아이언트 정보를 가져와서 사용
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

### 사용 예시

자동로그인 같이 보안상 중요한 작업을 수행할 때 사용

### 차이점

- 결국 세션도 쿠키를 사용해서 동작하기 때문에 거의 비슷함
- 가장 큰 차이점은 서버에 저장되냐, 브라우저에 저장되냐 차이
- 보안은 세션이 낫지만 요청 속도는 쿠키가 더 빠름
- 이러면 항상 세션을 사용하면 좋을 것 같지만 세션으로 서버 자원을 무분별하게 늘리다보면 메모리 과부하가 오거나 속도가 느려질 수 있기 때문에 쿠키를 사용하는 것이 유리할 경우가 있음
- **라이프사이클**: 쿠키도 만료시간이 있지만 파일로 저장되기 떄문에 브라우저를 종료해도 계속해서 정보가 남아있을 수 있음, 만료기간을 넉넉하게 잡아두면 쿠키 삭제 전까지 유지될 수 있음
- 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨 (크롬에서 다른 탭을 사용해도 세션은 공유됨, 브라우저를 다르게 쓰면 세션도 달라짐)

# 의존성 주입이란?

Dependency Injection

클래스 간의 의존성을 클래스 외부에서 주입하는 것

클래스에 대한 의존성의 인터페이스화를 통한 코드 유연성의 증대 + 클래스의 인스턴스를 외부에서 생성하여 주입하는 것

클래스간 의존성이 있다는 것은 한 클래스가 바뀔 때 다른 클래스도 영향을 받는다는 것

### 장점

- Unit Test 가 용이
- 코드의 재활용성을 높여줌
- 객체간 의존성을 줄이거나 없앨 수 있음
- 객체간 결합도를 낮추면서 유연한 코드를 작성할 수 있음
